var amqp = require("amqplib");


var channels = {
    input: {},
    return: {}
};

function connectToRabbitMQInputChannel(connection) {
    console.log("Trying to create a RabbitMQ Input Channel");
    var queue = "input";
    connection.createChannel()
    .then((chan) => {
        
        return chan.assertQueue(queue, {
            durable: false
        })
        .then((ok) => {
            channels.input = chan;
            console.log("Created a RabbitMQ Input Channel");
            if (process.env.ROLE == "worker") {
                return chan.consume(queue, function(msg) {
                    if (msg !== null) {
                        var parsedMsg = JSON.parse(msg.content);
                        console.log("Received RabbitMQ message: " + msg.content);
                        const redNodes = require("../nodes");
                        var currentNode = redNodes.getNode(parsedMsg._nodeId);
                        if (currentNode) {
                            currentNode.receive(parsedMsg.origMsg);
                        }
                        chan.ack(msg);
                    }
                });
            }
    
            return Promise.resolve();
        })
    })
    .catch((error) => {
        console.log(error);
        return setTimeout(connectToRabbitMQInputChannel, 1000);  
    });
}

function connectToRabbitMQReturnChannel(connection) {
    console.log("Trying to create a RabbitMQ Return Channel");
    var queue = "return";
    connection.createChannel()
    .then((chan) => {
        
        return chan.assertQueue(queue, {
            durable: false
        })
        .then((ok) => {
            channels.return = chan;
            console.log("Created a RabbitMQ Return Channel");
            if (process.env.ROLE == "client") {
                return chan.consume(queue, function(msg) {
                    if (msg !== null) {
                        var parsedMsg = JSON.parse(msg.content);
                        console.log("Received RabbitMQ message: " + msg.content);

                        // Find the specified node from within the flow
                        const redNodes = require("../nodes");
                        var currentNode = redNodes.getNode(parsedMsg._nodeId);
                        if (currentNode) {
                            console.log("Current node type: " + currentNode.type);
                            currentNode.receive(parsedMsg.origMsg);
                        }
                        chan.ack(msg);
                    }
                });
            }
    
            return Promise.resolve();
        })
    })
    .catch((error) => {
        console.log(error);
        return setTimeout(connectToRabbitMQReturnChannel, 1000);  
    });
}

function openRabbitMQConnection() {
    console.log("Trying to open a connection with RabbitMQ");
    amqp.connect("amqp://rabbitmq").then((conn) => {
        console.log("Successfully opened a connection with RabbitMQ");
        connectToRabbitMQInputChannel(conn);
        connectToRabbitMQReturnChannel(conn);
    })
    .catch((err) => {
        setTimeout(openRabbitMQConnection, 1000);
    })
}

function sendInputMsg(msg) {
    console.log("Sending message to RabbitMQ Input Queue");
    return channels.input.sendToQueue("input", Buffer.from(JSON.stringify(msg)));
}

function sendReturnMsg(msg) {
  console.log("Sending message to RabbitMQ Return Queue");
    return channels.return.sendToQueue("return", Buffer.from(JSON.stringify(msg)));
}


module.exports = {
    init: openRabbitMQConnection,
    input: sendInputMsg,
    return: sendReturnMsg
}